import numpy as np
import pandas as pd
from datetime import datetime

def classify_ndvi(ndvi_array, threshold=0.2):
    """
    Classifies NDVI data into 'Healthy' and 'Degraded' based on a threshold.
    """
    # Replace no-data values with NaN to ignore them in calculations
    ndvi_array[ndvi_array == -9999] = np.nan

    degraded_pixels = np.sum(ndvi_array < threshold)
    healthy_pixels = np.sum(ndvi_array >= threshold)
    total_pixels = degraded_pixels + healthy_pixels

    if total_pixels == 0:
        return 0.0, None

    degradation_percentage = (degraded_pixels / total_pixels) * 100
    
    # Create a classified array for potential future visualization
    classified_array = np.zeros(ndvi_array.shape)
    classified_array[ndvi_array >= threshold] = 1  # Healthy

    return degradation_percentage, classified_array

def create_report_csv(aoi, degradation_percentage, threshold=0.2):
    """
    Generates a comprehensive CSV report.
    """
    # Get the bounding box of the AOI
    coords = aoi['coordinates'][0]
    min_lon = min(p[0] for p in coords)
    max_lon = max(p[0] for p in coords)
    min_lat = min(p[1] for p in coords)
    max_lat = max(p[1] for p in coords)
    
    # Calculate area (approximate)
    area_sq_km = approximate_area(min_lon, max_lon, min_lat, max_lat)
    
    # Health assessment
    if degradation_percentage < 10:
        health_status = "Excellent"
        recommendation = "Maintain current practices"
    elif degradation_percentage < 25:
        health_status = "Good" 
        recommendation = "Monitor vegetation health"
    elif degradation_percentage < 40:
        health_status = "Moderate"
        recommendation = "Implement conservation measures"
    else:
        health_status = "Poor"
        recommendation = "Urgent restoration needed"

    data = {
        'Metric': [
            'Report Generated',
            'Land Health Status',
            'Vegetation Health Score',
            'Degraded Area Percentage', 
            'Healthy Area Percentage',
            'NDVI Analysis Threshold',
            'Approximate Area (sq km)',
            'Bounding Box Min Longitude',
            'Bounding Box Max Longitude', 
            'Bounding Box Min Latitude',
            'Bounding Box Max Latitude',
            'Recommended Action',
            'Analysis Confidence'
        ],
        'Value': [
            datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            health_status,
            f"{100 - degradation_percentage:.1f}%",
            f"{degradation_percentage:.2f}%",
            f"{100 - degradation_percentage:.2f}%", 
            f"{threshold}",
            f"{area_sq_km:.2f}",
            f"{min_lon:.6f}",
            f"{max_lon:.6f}",
            f"{min_lat:.6f}",
            f"{max_lat:.6f}",
            recommendation,
            "High (Satellite-based)"
        ]
    }
    
    df = pd.DataFrame(data)
    
    # Add header with credits
    report_header = f"TerraScan Land Health Report\nGenerated by Rosemary Emeli & Gideon Thuku\n{'-'*50}\n"
    csv_content = report_header + '\n' + df.to_csv(index=False)
    
    return csv_content.encode('utf-8')

def approximate_area(min_lon, max_lon, min_lat, max_lat):
    """
    Approximate area in square kilometers using haversine formula.
    """
    from math import radians, sin, cos, sqrt, atan2
    
    # Haversine function
    def haversine(lon1, lat1, lon2, lat2):
        R = 6371  # Earth radius in km
        dlon = radians(lon2 - lon1)
        dlat = radians(lat2 - lat1)
        a = sin(dlat/2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)**2
        c = 2 * atan2(sqrt(a), sqrt(1-a))
        return R * c
    
    # Calculate approximate width and height
    width_km = haversine(min_lon, (min_lat + max_lat)/2, max_lon, (min_lat + max_lat)/2)
    height_km = haversine((min_lon + max_lon)/2, min_lat, (min_lon + max_lon)/2, max_lat)
    
    return width_km * height_km